"use client";

/* eslint-disable tailwindcss/classnames-order, no-alert */

import { createOAuthClient, deleteOAuthClient, getOAuthClients, rotateClientSecret, updateOAuthClient } from "@foundry/iam/actions/oauth";
import { Badge } from "@foundry/ui/primitives/badge";
import { Button } from "@foundry/ui/primitives/button";
import { Card, CardDescription, CardHeader, CardTitle } from "@foundry/ui/primitives/card";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@foundry/ui/primitives/dialog";
import { Input } from "@foundry/ui/primitives/input";
import { Label } from "@foundry/ui/primitives/label";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@foundry/ui/primitives/table";
import { Textarea } from "@foundry/ui/primitives/textarea";
import { useCallback, useEffect, useMemo, useState } from "react";
import { toast } from "sonner";

// Narrow server-action imports to predictable client-side call shapes so
// TypeScript stays strict but the runtime wrapper (generated by Next) can be used
// directly from this client component.
const getOAuthClientsClient = getOAuthClients as unknown as () => Promise<unknown>;
const createOAuthClientClient = createOAuthClient as unknown as (body: Record<string, unknown>) => Promise<unknown>;
const rotateClientSecretClient = rotateClientSecret as unknown as (clientId: string) => Promise<unknown>;
const deleteOAuthClientClient = deleteOAuthClient as unknown as (clientId: string) => Promise<unknown>;
const updateOAuthClientClient = updateOAuthClient as unknown as (clientId: string, update: Record<string, unknown>) => Promise<unknown>;

interface OAuthClient {
    id?: string;
    client_id: string;
    name?: string | null;
    redirect_uris?: string[];
    grant_types?: string[];
    created_at?: string | null;
    enabled?: boolean | null;
}

const LINE_SPLIT_RE = /\r?\n/;

export default function OAuthManagementPage() {
    const [clients, setClients] = useState<OAuthClient[]>([]);
    const [loading, setLoading] = useState(false);

    const [createOpen, setCreateOpen] = useState(false);
    const [creating, setCreating] = useState(false);
    const [newName, setNewName] = useState("");
    const [newRedirects, setNewRedirects] = useState("");
    // client type (web = confidential, user-agent-based = public/native)
    const [clientType, setClientType] = useState<"web" | "native" | "user-agent-based">("web");

    // scope selection (serialized as space-separated string for the server)
    const AVAILABLE_SCOPES = ["openid", "profile", "email", "offline_access"] as const;
    const [selectedScopes, setSelectedScopes] = useState<string[]>(["openid", "profile", "email"]);

    const [secretDialogOpen, setSecretDialogOpen] = useState(false);
    const [oneTimeSecret, setOneTimeSecret] = useState<string | null>(null);
    const [pendingDeleteClientId, setPendingDeleteClientId] = useState<string | null>(null);
    // edit existing client's redirect URIs
    const [editOpen, setEditOpen] = useState(false);
    const [editingClient, setEditingClient] = useState<OAuthClient | null>(null);
    const [editRedirects, setEditRedirects] = useState("");
    const [updating, setUpdating] = useState(false);

    const loadClients = useCallback(async () => {
        setLoading(true);
        try {
            const data = (await getOAuthClientsClient()) as unknown;
            const list: OAuthClient[] = Array.isArray(data) ? (data as OAuthClient[]) : ((data as { clients?: OAuthClient[] })?.clients ?? []);
            setClients(list);
        } catch (err: unknown) {
            console.error(err);
            toast.error("Failed to load OAuth clients");
        } finally {
            setLoading(false);
        }
    }, []);

    useEffect(() => {
        loadClients();
    }, [loadClients]);

    const createDisabled = useMemo(() => creating || !newName.trim() || !newRedirects.trim(), [creating, newName, newRedirects]);

    async function handleCreateClient() {
        if (createDisabled) {
            return;
        }
        setCreating(true);
        try {
            const redirects = newRedirects
                .split(LINE_SPLIT_RE)
                .map((s) => s.trim())
                .filter(Boolean);

            const body: Record<string, unknown> = {
                client_name: newName.trim(),
                redirect_uris: redirects,
                // server expects a space-separated `scope` string (RFC7591 style)
                scope: (selectedScopes ?? []).filter(Boolean).join(" ") || undefined,
                // indicate public vs confidential by `type` (accepted by server schema)
                type: clientType,
            };

            const data = (await createOAuthClientClient(body)) as { client_secret?: string } & Record<string, unknown>;
            await loadClients();

            // show one-time client secret when returned
            if (data?.client_secret) {
                setOneTimeSecret(data.client_secret);
                setSecretDialogOpen(true);
            } else {
                toast.success("Client created");
            }

            setCreateOpen(false);
            setNewName("");
            setNewRedirects("");
        } catch (err: unknown) {
            console.error(err);
            // try to extract message if possible
            const msg = err instanceof Error ? err.message : String(err);
            toast.error(msg || "Create failed");
        } finally {
            setCreating(false);
        }
    }

    async function handleRotateSecret(clientId: string) {
        try {
            const data = (await rotateClientSecretClient(clientId)) as { client_secret?: string } & Record<string, unknown>;
            if (data?.client_secret) {
                setOneTimeSecret(data.client_secret);
                setSecretDialogOpen(true);
            } else {
                toast.success("Secret rotated");
            }
            await loadClients();
        } catch (err: unknown) {
            console.error(err);
            const msg = err instanceof Error ? err.message : String(err);
            toast.error(msg || "Rotate failed");
        }
    }

    async function handleDelete(clientId: string) {
        setPendingDeleteClientId(clientId);
    }

    async function performDelete() {
        const clientId = pendingDeleteClientId;
        if (!clientId) {
            return;
        }
        setPendingDeleteClientId(null);
        try {
            await deleteOAuthClientClient(clientId);
            toast.success("Client deleted");
            await loadClients();
        } catch (err: unknown) {
            console.error(err);
            const msg = err instanceof Error ? err.message : String(err);
            toast.error(msg || "Delete failed");
        }
    }

    return (
        <div className="container mx-auto py-8">
            <div className="mb-6 flex items-center justify-between gap-4">
                <div>
                    <h1 className="font-semibold text-2xl">OAuth Clients</h1>
                    <p className="text-muted-foreground text-sm">Manage registered OAuth clients for this issuer.</p>
                </div>
                <div className="flex items-center gap-2">
                    <Button disabled={loading} onClick={loadClients} variant="outline">
                        Refresh
                    </Button>
                    <Button onClick={() => setCreateOpen(true)}>Create client</Button>
                </div>
            </div>

            <Card>
                <CardHeader>
                    <CardTitle>Registered clients</CardTitle>
                    <CardDescription>Clients can be created, deleted and their secret rotated (secret is shown only once).</CardDescription>
                </CardHeader>
                <div className="p-4">
                    <Table>
                        <TableHeader>
                            <TableRow>
                                <TableHead>Name</TableHead>
                                <TableHead>Client ID</TableHead>
                                <TableHead>Redirect URIs</TableHead>
                                <TableHead>Grants</TableHead>
                                <TableHead>Created</TableHead>
                                <TableHead>Status</TableHead>
                                <TableHead>Actions</TableHead>
                            </TableRow>
                        </TableHeader>
                        <TableBody>
                            {clients.map((c) => (
                                <TableRow key={c.client_id}>
                                    <TableCell className="w-56 max-w-xs truncate">{c.name ?? "(untitled)"}</TableCell>
                                    <TableCell className="font-mono">{c.client_id}</TableCell>
                                    <TableCell>
                                        <div className="flex flex-col text-sm">
                                            {(c.redirect_uris ?? []).slice(0, 2).map((r) => (
                                                <CardDescription className="truncate" key={r}>
                                                    {r}
                                                </CardDescription>
                                            ))}
                                            {(c.redirect_uris ?? []).length > 2 ? (
                                                <CardDescription className="truncate">+{(c.redirect_uris ?? []).length - 2} more</CardDescription>
                                            ) : null}
                                        </div>
                                    </TableCell>
                                    <TableCell>
                                        {(c.grant_types ?? []).map((g) => (
                                            <Badge className="mr-1" key={g}>
                                                {g}
                                            </Badge>
                                        ))}
                                    </TableCell>
                                    <TableCell className="font-mono text-sm">{c.created_at ? new Date(c.created_at).toLocaleString() : "—"}</TableCell>
                                    <TableCell>{c.enabled === false ? <Badge variant="outline">Disabled</Badge> : <Badge>Active</Badge>}</TableCell>
                                    <TableCell>
                                        <div className="flex gap-2">
                                            <Button
                                                onClick={() => {
                                                    navigator.clipboard.writeText(c.client_id).then(() => toast.success("Client ID copied"));
                                                }}
                                                size="sm"
                                                variant="ghost"
                                            >
                                                Copy ID
                                            </Button>
                                            <Button
                                                onClick={() => {
                                                    setEditingClient(c);
                                                    setEditRedirects((c.redirect_uris ?? []).join("\n"));
                                                    setEditOpen(true);
                                                }}
                                                size="sm"
                                                variant="ghost"
                                            >
                                                Edit
                                            </Button>
                                            <Button onClick={() => handleRotateSecret(c.client_id)} size="sm" variant="secondary">
                                                Rotate secret
                                            </Button>
                                            <Button onClick={() => handleDelete(c.client_id)} size="sm" variant="destructive">
                                                Delete
                                            </Button>
                                        </div>
                                    </TableCell>
                                </TableRow>
                            ))}
                        </TableBody>
                    </Table>
                    {clients.length === 0 ? <div className="py-6 text-center text-muted-foreground text-sm">No clients registered</div> : null}
                </div>
            </Card>

            {/* Create dialog */}
            <Dialog onOpenChange={setCreateOpen} open={createOpen}>
                <DialogContent>
                    <DialogHeader>
                        <DialogTitle>Create OAuth client</DialogTitle>
                        <DialogDescription>Provide a name and at least one redirect URI. The client secret (if any) will be shown once.</DialogDescription>
                    </DialogHeader>

                    <div className="grid gap-3 py-4">
                        <div>
                            <Label htmlFor="client-name">Name</Label>
                            <Input id="client-name" onChange={(e) => setNewName(e.target.value)} placeholder="My app" value={newName} />
                        </div>
                        <div>
                            <Label htmlFor="redirect-uris">Redirect URIs (one per line)</Label>
                            <Textarea
                                id="redirect-uris"
                                onChange={(e) => setNewRedirects(e.target.value)}
                                placeholder="https://example.com/callback"
                                rows={4}
                                value={newRedirects}
                            />
                        </div>
                        <div>
                            <Label>Client type</Label>
                            <div className="mt-2 flex items-center gap-4">
                                <label className="flex items-center gap-2">
                                    <input checked={clientType === "web"} name="client-type" onChange={() => setClientType("web")} type="radio" />
                                    <span className="text-sm">Confidential (web)</span>
                                </label>
                                <label className="flex items-center gap-2">
                                    <input checked={clientType === "user-agent-based"} name="client-type" onChange={() => setClientType("user-agent-based")} type="radio" />
                                    <span className="text-sm">Public (user-agent)</span>
                                </label>
                                <label className="flex items-center gap-2">
                                    <input checked={clientType === "native"} name="client-type" onChange={() => setClientType("native")} type="radio" />
                                    <span className="text-sm">Native</span>
                                </label>
                            </div>
                        </div>

                        <div>
                            <Label>Scopes</Label>
                            <div className="mt-2 grid grid-cols-2 gap-2">
                                {AVAILABLE_SCOPES.map((s) => (
                                    <label className="inline-flex items-center gap-2 text-sm" key={s}>
                                        <input
                                            checked={selectedScopes.includes(s)}
                                            onChange={(e) => {
                                                setSelectedScopes((prev) => (e.target.checked ? Array.from(new Set([...prev, s])) : prev.filter((v) => v !== s)));
                                            }}
                                            type="checkbox"
                                        />
                                        <span className="capitalize">{s.replace("_", " ")}</span>
                                    </label>
                                ))}
                            </div>
                        </div>
                    </div>

                    <DialogFooter>
                        <Button onClick={() => setCreateOpen(false)} variant="ghost">
                            Cancel
                        </Button>
                        <Button disabled={createDisabled} onClick={handleCreateClient}>
                            {creating ? "Creating…" : "Create"}
                        </Button>
                    </DialogFooter>
                </DialogContent>
            </Dialog>

            {/* Edit redirects dialog */}
            <Dialog
                onOpenChange={(open) => {
                    if (!open) {
                        setEditingClient(null);
                        setEditRedirects("");
                    }
                    setEditOpen(open);
                }}
                open={editOpen}
            >
                <DialogContent>
                    <DialogHeader>
                        <DialogTitle>Edit Redirect URIs</DialogTitle>
                        <DialogDescription>Update the redirect URIs for the selected client (one per line).</DialogDescription>
                    </DialogHeader>

                    <div className="grid gap-3 py-4">
                        <div>
                            <Label>Client</Label>
                            <Input readOnly value={editingClient?.name ?? editingClient?.client_id ?? ""} />
                        </div>
                        <div>
                            <Label htmlFor="edit-redirect-uris">Redirect URIs (one per line)</Label>
                            <Textarea
                                id="edit-redirect-uris"
                                onChange={(e) => setEditRedirects(e.target.value)}
                                placeholder="https://example.com/callback"
                                rows={4}
                                value={editRedirects}
                            />
                        </div>
                    </div>

                    <DialogFooter>
                        <Button
                            onClick={() => {
                                setEditOpen(false);
                            }}
                            variant="ghost"
                        >
                            Cancel
                        </Button>
                        <Button
                            disabled={updating || !editRedirects.trim() || !editingClient}
                            onClick={async () => {
                                if (!editingClient) {
                                    return;
                                }
                                setUpdating(true);
                                try {
                                    const redirects = editRedirects
                                        .split(LINE_SPLIT_RE)
                                        .map((s) => s.trim())
                                        .filter(Boolean);

                                    await updateOAuthClientClient(editingClient.client_id, { redirect_uris: redirects });
                                    toast.success("Redirect URIs updated");
                                    setEditOpen(false);
                                    setEditingClient(null);
                                    setEditRedirects("");
                                    await loadClients();
                                } catch (err: unknown) {
                                    console.error(err);
                                    const msg = err instanceof Error ? err.message : String(err);
                                    toast.error(msg || "Update failed");
                                } finally {
                                    setUpdating(false);
                                }
                            }}
                        >
                            {updating ? "Saving…" : "Save"}
                        </Button>
                    </DialogFooter>
                </DialogContent>
            </Dialog>

            {/* Delete confirmation dialog */}
            <Dialog
                onOpenChange={(open) => {
                    if (!open) {
                        setPendingDeleteClientId(null);
                    }
                }}
                open={Boolean(pendingDeleteClientId)}
            >
                <DialogContent>
                    <DialogHeader>
                        <DialogTitle>Delete OAuth client</DialogTitle>
                        <DialogDescription>This action will permanently remove the client and revoke its credentials. Proceed?</DialogDescription>
                    </DialogHeader>
                    <DialogFooter>
                        <Button onClick={() => setPendingDeleteClientId(null)} variant="ghost">
                            Cancel
                        </Button>
                        <Button
                            onClick={() => {
                                performDelete();
                            }}
                            variant="destructive"
                        >
                            Delete
                        </Button>
                    </DialogFooter>
                </DialogContent>
            </Dialog>

            {/* One-time secret dialog */}
            <Dialog
                onOpenChange={(open) => {
                    if (!open) {
                        setOneTimeSecret(null);
                    }
                    setSecretDialogOpen(open);
                }}
                open={secretDialogOpen}
            >
                <DialogContent>
                    <DialogHeader>
                        <DialogTitle>Client secret (one-time)</DialogTitle>
                        <DialogDescription>Copy this secret now — it will not be shown again.</DialogDescription>
                    </DialogHeader>
                    <div className="mt-4">
                        <div className="rounded-md border p-3">
                            <CardDescription className="break-all font-mono">{oneTimeSecret ?? ""}</CardDescription>
                        </div>
                        <div className="mt-3 flex gap-2">
                            <Button
                                onClick={async () => {
                                    if (!oneTimeSecret) {
                                        return;
                                    }
                                    await navigator.clipboard.writeText(oneTimeSecret);
                                    toast.success("Secret copied to clipboard");
                                }}
                            >
                                Copy secret
                            </Button>
                            <Button
                                onClick={() => {
                                    setSecretDialogOpen(false);
                                    setOneTimeSecret(null);
                                }}
                                variant="ghost"
                            >
                                Close
                            </Button>
                        </div>
                    </div>
                </DialogContent>
            </Dialog>
        </div>
    );
}
